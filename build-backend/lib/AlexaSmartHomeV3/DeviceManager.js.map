{"version":3,"file":"DeviceManager.js","sourceRoot":"","sources":["../../../src/lib/AlexaSmartHomeV3/DeviceManager.ts"],"names":[],"mappings":"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","sourcesContent":["import Device from './Device';\nimport * as Utils from './Helpers/Utils';\nimport Directives from './Alexa/Directives';\nimport Controls from './Controls';\nimport type Control from './Controls/Control';\nimport Logger from './Helpers/Logger';\nimport AdapterProvider from './Helpers/AdapterProvider';\nimport AlexaResponse from './Alexa/AlexaResponse';\nimport IotProxy from './Helpers/IotProxy';\nimport RateLimiter from './Helpers/RateLimiter';\nimport OverallDailyRateLimitExceeded from './Exceptions/OverallDailyRateLimitExceeded';\nimport HourlyDeviceRateLimitExceeded from './Exceptions/HourlyDeviceRateLimitExceeded';\nimport type { AlexaV3EndpointID, AlexaV3Request, IotExternalPatternControl } from './types';\nimport ChangeReport from './Alexa/Directives/ChangeReport';\nimport Discovery from './Alexa/Directives/Discovery';\nimport ReportState from './Alexa/Directives/ReportState';\nimport { randomUUID } from 'node:crypto';\n\nexport default class DeviceManager {\n    private lang: ioBroker.Languages = 'en';\n    private devices: Device[] = [];\n    private subscribed: string[] = [];\n    private log: Logger;\n    private eventsPausedTill = 0; // timestamp\n\n    private collecting = false;\n    private recollect = false;\n\n    /** Creates a Device Manager */\n    constructor() {\n        this.log = new Logger(this);\n    }\n\n    informAboutStatesChange(): void {\n        void AdapterProvider.get().setState('smart.updates3', true, true);\n    }\n\n    get language(): ioBroker.Languages {\n        return this.lang;\n    }\n\n    set language(value: ioBroker.Languages) {\n        this.lang = value;\n    }\n\n    matchDirective(event: AlexaV3Request): ChangeReport | Discovery | ReportState | null {\n        if (ChangeReport.matches(event)) {\n            return new ChangeReport();\n        }\n        if (Discovery.matches(event)) {\n            return new Discovery();\n        }\n        if (ReportState.matches(event)) {\n            return new ReportState();\n        }\n\n        return null;\n    }\n\n    get endpoints(): Device[] {\n        return this.devices;\n    }\n\n    endpointById(id: AlexaV3EndpointID): Device | undefined {\n        return this.devices.find(device => device.id === id);\n    }\n\n    addDevice(device: Device): void {\n        this.devices.push(device);\n    }\n\n    toDevice(\n        detectedControls: IotExternalPatternControl[],\n        friendlyName: string,\n        autoDetected: boolean,\n        roomName: string | undefined,\n        funcName: string | undefined,\n        toggle?: boolean,\n    ): Device | undefined {\n        const controls: Control[] = [];\n\n        this.log.debug(`merging controls to a device with name ${friendlyName}`);\n\n        detectedControls.forEach(item => {\n            this.log.silly(`processing control: ${JSON.stringify(item)}`);\n            const control = Controls.factory(item);\n            if (control) {\n                this.log.debug(`${item.type} added to ${friendlyName}`);\n                controls.push(control);\n            } else {\n                this.log.debug(`control of type ${item.type} not supported yet. Skipped.`);\n            }\n        });\n\n        if (controls.length === 0) {\n            // the controls are not supported yet...\n            return;\n        }\n\n        // create and add a new device to the collected devices\n        this.addDevice(\n            new Device({\n                id: friendlyName,\n                friendlyName,\n                controls,\n                autoDetected,\n                roomName,\n                funcName,\n                toggle,\n            }),\n        );\n    }\n\n    getName(name: ioBroker.StringOrTranslated | undefined): string {\n        if (!name) {\n            return '';\n        }\n        if (typeof name === 'object') {\n            return name[this.lang] || name.en || '';\n        }\n        return name;\n    }\n\n    async collectEndpoints(): Promise<void> {\n        if (this.collecting) {\n            this.log.debug(`collecting devices already in progress. Skipping...`);\n            this.recollect = true;\n            return;\n        }\n        this.collecting = true;\n        this.log.debug(`(re)collecting devices...`);\n        try {\n            // const discoveryNeeded = this.devices.length > 0;\n\n            this.devices = [];\n            const defaultToggle = AdapterProvider.get().config.defaultToggle || false;\n\n            // collect all iobroker controls in terms of iobroker type detector (https://github.com/ioBroker/ioBroker.type-detector)\n            let detectedControls = await Utils.controls(AdapterProvider.get(), this.lang);\n\n            this.log.debug(`type detector found ${detectedControls.length} controls`);\n\n            // Normally, every control is a smart device. But due to the iobroker concept of 'rooms and functions'\n            // multiple controls might be merged to a single device.\n\n            // as long as not all controls mapped to a device...\n\n            // detectedControls = detectedControls.filter(c => ['light', 'dimmer'].includes(c.type));\n            const createdGroups: string[] = [];\n\n            while (detectedControls.length) {\n                // take the next control\n                const control = detectedControls[0];\n                let processedControls: IotExternalPatternControl[] = [];\n\n                if (control.room?.common?.name) {\n                    if (control.functionality?.common?.name) {\n                        // controls in the same room with the same functionality\n                        processedControls = detectedControls.filter(\n                            item =>\n                                control.room &&\n                                item.room?.id === control.room.id &&\n                                control.functionality &&\n                                item.functionality?.id === control.functionality.id,\n                        );\n                        this.toDevice(\n                            processedControls,\n                            Utils.friendlyNameByRoomAndFunctionName(control, this.lang),\n                            true,\n                            this.getName(control.room?.common?.name),\n                            this.getName(control.functionality?.common?.name),\n                            processedControls[0].object?.toggle ?? defaultToggle,\n                        );\n                    } else {\n                        this.log.debug(\n                            `Control of type [${control.type}] assigned to room [${this.getName(control.room.common.name)}] has no function. Skipped.`,\n                        );\n                    }\n                } else if (control.groupNames) {\n                    // no room, but smart name (not only one)\n                    control.groupNames.forEach(groupName => {\n                        if (!createdGroups.includes(groupName)) {\n                            createdGroups.push(groupName);\n                            processedControls = detectedControls.filter(item => item.groupNames?.includes(groupName));\n                            this.toDevice(\n                                processedControls,\n                                this.getName(groupName),\n                                false,\n                                undefined,\n                                undefined,\n                                processedControls[0].object?.toggle ?? defaultToggle,\n                            );\n                        }\n                    });\n                } else {\n                    // neither room nor smart name\n                    this.log.debug(`Control of type [${control.type}] has neither room no smart name. Skipped.`);\n                }\n\n                if (processedControls.length === 0) {\n                    processedControls = [control];\n                }\n\n                // remove processed controls\n                const objectIds = processedControls.map(item => item.object?.id);\n                detectedControls = detectedControls.filter(item => item.object && !objectIds.includes(item.object.id));\n            }\n\n            // done\n            this.log.debug(`finished collecting devices. there is/are ${this.devices.length} device(s) in total`);\n            for (const device of this.devices) {\n                this.log.debug(`${device.toString()}`);\n            }\n\n            // a new discovery process is needed in case we had already devices and device collection was\n            // triggered again by, e.g., a change in room/function enums\n            // if (discoveryNeeded) {\n            //     this.log.info(`Please delete all managed by ioBroker devices in your Alexa app and then start discovery`);\n            // }\n\n            // collect all relevant states to subscribe to updates\n            const stateIds = new Set(\n                this.devices\n                    .flatMap(d => d.controls)\n                    .flatMap(item => item.supported)\n                    .flatMap(item => item.properties)\n                    .map(item => item.getId)\n                    .filter(id => id),\n            );\n            this.log.debug(`registering for updates of total ${stateIds.size} states`);\n            const promises = [];\n            const newSubscribed = Array.from(stateIds);\n            // subscribe to updates\n            for (const id of newSubscribed) {\n                this.log.silly(`subscribing to updates of ${id}`);\n                if (!this.subscribed.includes(id)) {\n                    this.subscribed.push(id);\n                    promises.push(AdapterProvider.subscribe(id));\n                }\n            }\n\n            this.subscribed.sort();\n\n            // wait till all promises are settled\n            const results = await Promise.allSettled(promises);\n\n            // unsubscribe from unused states\n            for (let i = this.subscribed.length - 1; i >= 0; i--) {\n                const id = this.subscribed[i];\n                if (!newSubscribed.includes(id)) {\n                    this.log.silly(`unsubscribing from updates of ${id}`);\n                    this.subscribed.splice(i, 1);\n                    await AdapterProvider.unsubscribe(id);\n                }\n            }\n\n            const failedReasons = results.filter(item => item.status !== 'fulfilled').flatMap(item => item.reason);\n            if (failedReasons.length) {\n                this.log.debug(`failed to subscribe for updates of ${failedReasons.length} states`);\n                try {\n                    for (const reason of failedReasons) {\n                        this.log.silly(\n                            `failed subscribing: ${typeof reason === 'string' ? reason : JSON.stringify(reason)}`,\n                        );\n                    }\n                } catch {\n                    // nop\n                }\n            }\n        } catch (e) {\n            this.log.error(`failed to collect devices: ${e}`);\n        }\n\n        this.collecting = false;\n\n        // if during the collection a new collection was triggered, start collecting again\n        if (this.recollect) {\n            this.recollect = false;\n            setTimeout(() => this.collectEndpoints(), 1000);\n        }\n    }\n\n    async destroy(): Promise<void> {\n        const promises = [];\n        for (const id of this.subscribed) {\n            this.log.silly(`unsubscribing from updates of ${id}`);\n            promises.push(AdapterProvider.subscribe(id));\n        }\n        await Promise.allSettled(promises);\n\n        this.subscribed = [];\n    }\n\n    publishStateChange(stateChange: AlexaResponse): void {\n        if (this.eventsPausedTill < Date.now()) {\n            this.log.silly(`publishing ${JSON.stringify(stateChange)}`);\n            IotProxy.publishStateChange(stateChange);\n        }\n    }\n\n    pauseEvents(): void {\n        this.eventsPausedTill = Date.now() + 30 * 60 * 1000; // 30 minutes\n    }\n\n    async executeWithinRateLimits(\n        endpointId: AlexaV3EndpointID,\n        awaitable: () => Promise<AlexaResponse>,\n        errorResponse: AlexaResponse,\n    ): Promise<AlexaResponse> {\n        try {\n            await RateLimiter.incrementAndGet(endpointId);\n            return await awaitable();\n        } catch (error) {\n            if (error instanceof OverallDailyRateLimitExceeded || error instanceof HourlyDeviceRateLimitExceeded) {\n                this.log.warn(error.message);\n            } else {\n                this.log.error(error.message);\n            }\n\n            return errorResponse;\n        }\n    }\n\n    async handleAlexaEvent(event: AlexaV3Request): Promise<AlexaResponse> {\n        this.log.debug(`incoming Alexa event`);\n        this.log.silly(`${JSON.stringify(event)}`);\n        if (!event?.directive?.header) {\n            throw new Error('Alexa event header is missing');\n        }\n\n        let response: AlexaResponse;\n        const directive = this.matchDirective(event);\n        if (directive) {\n            response = await directive.handle(event, this);\n        } else {\n            const endpointId = event?.directive?.endpoint?.endpointId;\n            const device = endpointId ? this.endpointById(endpointId) : undefined;\n\n            if (device) {\n                if (device.supports(event)) {\n                    response = await this.executeWithinRateLimits(\n                        endpointId!,\n                        async () => {\n                            response = await device.handle(event);\n                            if (!AlexaResponse.isErrorResponse(response)) {\n                                // report state change via voice interaction\n                                const propertyName = response.context?.properties[0].name;\n                                const responseEvent = ChangeReport.get(\n                                    device.id,\n                                    propertyName || '',\n                                    false,\n                                    event.directive.header.messageId,\n                                );\n                                const directive = this.matchDirective(responseEvent);\n                                if (directive) {\n                                    // BF[2024.02.04]: temporarily disabled as produced a huge number of events\n                                    // const stateChange = await directive.handle(responseEvent, this);\n                                    // get device state (not just one control)\n                                    const deviceState = await device.reportState();\n                                    if (JSON.stringify(device.lastReportedState) !== JSON.stringify(deviceState)) {\n                                        device.lastReportedState = deviceState;\n                                        // fire state change report to Alexa\n                                        // BF[2024.02.04]: temporarily disabled as produced a huge number of events\n                                        // this.publishStateChange(stateChange);\n                                        this.informAboutStatesChange();\n                                    } else {\n                                        this.log.debug(\n                                            `ignoring state change event for ${endpointId} due to the same_ value [${JSON.stringify(deviceState)}]`,\n                                        );\n                                    }\n                                }\n                            }\n                            return response;\n                        },\n                        AlexaResponse.endpointUnreachable(event.directive.header.messageId).get(),\n                    );\n                } else {\n                    response = AlexaResponse.directiveNotSupportedByDevice(\n                        device.friendlyName,\n                        event.directive.header.namespace,\n                        event.directive.header.messageId,\n                        event.directive.header.payloadVersion,\n                    ).get();\n                }\n            } else {\n                response = AlexaResponse.endpointUnreachable(event.directive.header.messageId).get();\n            }\n        }\n\n        this.log.silly(`response: ${JSON.stringify(response)}`);\n        return response;\n    }\n\n    async handleStateUpdate(id: string, state: ioBroker.State | null | undefined): Promise<void> {\n        // ignore updates not confirmed by a corresponding device\n        if (!state?.ack) {\n            this.log.silly(`ignoring state change event for ${id} due to state.ack == ${state?.ack}`);\n            return;\n        }\n\n        let notFound = true;\n\n        for (const device of this.devices) {\n            const property = device.controls\n                .flatMap(item => item.supported)\n                .flatMap(item => item.properties)\n                .find(item => item.getId === id);\n\n            if (property) {\n                notFound = false;\n                if (property.currentValue === state.val) {\n                    this.log.debug(`ignoring state change event for ${id} due to the same value [${state.val}]`);\n                } else {\n                    property.currentValue = state.val;\n\n                    const responseEvent = Directives.ChangeReport.get(\n                        device.id,\n                        property.propertyName,\n                        true,\n                        randomUUID(),\n                    );\n                    const directive = this.matchDirective(responseEvent);\n                    if (directive) {\n                        // BF[2024.02.04]: temporarily disabled as produced a huge number of events\n                        // const stateChange = await directive.handle(event, this);\n\n                        // get device state (not just one control)\n                        const deviceState = await device.reportState();\n\n                        if (JSON.stringify(device.lastReportedState) !== JSON.stringify(deviceState)) {\n                            device.lastReportedState = deviceState;\n                            this.informAboutStatesChange();\n                            // fire state change report to Alexa\n\n                            // BF[2024.02.04]: temporarily disabled as produced a huge number of events\n                            // await this.executeWithinRateLimits(device.id, async () =>\n                            //     this.publishStateChange(stateChange), undefined);\n                        } else {\n                            this.log.debug(\n                                `ignoring state change event for ${id} due to the same_ value [${JSON.stringify(deviceState)}]`,\n                            );\n                        }\n                    }\n                }\n\n                // should be the only device having the id => stop processing here\n                break;\n            }\n        }\n\n        // this should never happen\n        if (notFound) {\n            this.log.debug(`state id ${id} doesn't belong to any device`);\n        }\n    }\n}\n"]}